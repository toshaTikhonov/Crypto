#include "Prng.h"
#include "Aes.h"
#include "Rsa/Rsaref.h"
#include "Rsa/r_random.h"

#define CIPHER_BLOCK_SIZE 16
#define KEY_SIZE CIPHER_BLOCK_SIZE

static UINT8 m_Seed[CIPHER_BLOCK_SIZE];
static UINT8 m_Counter[CIPHER_BLOCK_SIZE];

static aes_context m_Aes;


static void aux_IncCounter(UINT8 Buffer[CIPHER_BLOCK_SIZE])
{
    UINT16 i, carry;

    carry = 1;
    for(i = 0; i < CIPHER_BLOCK_SIZE; ++i)
    {
        carry    += Buffer[i];
        Buffer[i] = (UINT8)carry;
        carry   >>= 8;                        
    }
}

URC Prng_Init(void)
{
    UINT8 i;
    UINT8 Key[CIPHER_BLOCK_SIZE];
    UINT16 TwoBytes;
    R_RANDOM_STRUCT randomStruct;

    randomStruct.bytesNeeded = 2;
    R_memset ((POINTER)randomStruct.state, 0, sizeof (randomStruct.state));
    randomStruct.outputAvailable = 0;

    if(R_GenerateBytes((unsigned char*)&TwoBytes,2,&randomStruct))
        return URC_CRYPTO_PRNG_INIT_FAILED;

    CRT_SeedRandom((UINT16)TwoBytes);

    for (i = 0; i < CIPHER_BLOCK_SIZE; i++)
    {
        m_Seed[i] = CRT_GetRandom(0, 255);
        Key[i] = CRT_GetRandom(0, 255);
        m_Counter[i] = CRT_GetRandom(0, 255);
    }

    crypto_aes_set_key(&m_Aes, Key, sizeof(Key));

    return URC_OK;

} /* Prng_Init */



/*
    Let ede*X(Y) represent the AES encryption of Y under the key *X.
    For AES 128-bit key, let *K be a 128 bit key.

    This *K is reserved only for the generation of pseudo random numbers.

    Let V be a 128-bit seed value which is also kept secret, and XOR be the exclusive-or operator. 
    Let DT be a date/time vector which is updated on each iteration. 
    I is a intermediate value. 
    A vector R is generated as follows (Note for AES implementations DT, I, and R are 128-bits each.):
    I = ede *K(DT)
    R = ede *K(I XOR V) and a new V is generated by V = ede*K(R Xor I).
*/
URC Prng_GetRandom(PUINT8 pBuffer, UINT16 BufferSize)
{
    UINT16 i, Len;
    
    UINT8 DT[CIPHER_BLOCK_SIZE];    /* текущая дата/время */
    UINT8 I[CIPHER_BLOCK_SIZE];     /* I = AES_k(D) */
    UINT8 ls[CIPHER_BLOCK_SIZE];    /* ls = l xor seed */
    UINT8 R[CIPHER_BLOCK_SIZE];     /* R = AES_k(ls) */
    UINT8 newV[CIPHER_BLOCK_SIZE];  /* newV = R xor I */
    R_RANDOM_STRUCT randomStruct;

#define XOR(r, a, b) {for (Len=0; Len<CIPHER_BLOCK_SIZE; Len++) r[Len]=a[Len]^b[Len];}    


    randomStruct.bytesNeeded = CIPHER_BLOCK_SIZE;
    R_memset ((POINTER)randomStruct.state, 0, sizeof (randomStruct.state));
    randomStruct.outputAvailable = 0;

    /*
    если когда-нибудь будем компилировать под платформу, где 
    доступен счетчик с высоким разрешением (больше 32-бит), то
    необходимо перенести вызов FillDate в начало цикла, чтобы DT
    обновлялся при каждой итерации. А пока берем только один раз перед
    входом в цикл
    */
    if (R_GenerateBytes(DT,16,&randomStruct))
        URC_LOG_RETURN(URC_CRYPTO_PRNG_RANDOM_FAILED);
    
    for(i = 0; i < BufferSize;)
    {
        crypto_aes_cbc_encrypt(&m_Aes, m_Counter, DT, I, CIPHER_BLOCK_SIZE); 
        aux_IncCounter(m_Counter);
        XOR(ls, I, m_Seed);

        crypto_aes_cbc_encrypt(&m_Aes, m_Counter, ls, R, CIPHER_BLOCK_SIZE);
        aux_IncCounter(m_Counter);
        XOR(newV, R, I);

        crypto_aes_cbc_encrypt(&m_Aes, m_Counter, newV, m_Seed, CIPHER_BLOCK_SIZE);
        aux_IncCounter(m_Counter);

        Len = BufferSize - i;
        if(Len > CIPHER_BLOCK_SIZE)
            Len = CIPHER_BLOCK_SIZE;

        MemCpy(&pBuffer[i], R, Len);

        i += Len;
    }

#undef XOR

    return URC_OK;
} /* Prng_GetRandom */
